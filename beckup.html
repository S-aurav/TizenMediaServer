<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Smart TV Streaming</title>
  <script src="$WEBAPIS/webapis/webapis.js"></script>
  <style>
    body {
      background: black;
      color: white;
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      justify-content: center;
    }

    .debug {
      font-size: 18px;
      color: yellow;
      padding: 10px;
      position: absolute;
      top: 0;
      left: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      max-width: 90%;
      word-wrap: break-word;
    }

    .screen {
      padding: 60px;
      height: 100vh;
      box-sizing: border-box;
    }

    .title {
      font-size: 48px;
      margin-bottom: 40px;
      text-align: center;
      color: #ff6b6b;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }

    /* POSTER Cards */
    .poster-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
      overflow-y: auto;
      max-height: auto;
    }

    .poster-card {
      width: 300px;
      height: 700px;
      background: #1c1c1c;
      border: 4px solid transparent;
      padding: 10px;
      border-radius: 3px;
    }

    .poster-card.selected {
      border-color: white;
    }

    .poster {
      width: 100%;
      height: 650px;
      object-fit: cover;
      border-radius: 3px;
    }

    /* SEASONS */
    .season-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
      overflow-y: auto;
      max-height: none;
    }

    .season-card {
      width: 280px;
      height: 250px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      text-align: center;
      font-weight: bold;
      border: 4px solid transparent;
      color: white;
      position: relative;
      overflow: hidden;
      background-size: cover;
      background-position: center;
    }

    .season-card::before {
      content: "";
      position: absolute;
      inset: 0;
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, 0.4);
    }

    .season-card span {
      position: relative;
      z-index: 1;
    }

    .season-card.selected {
      border-color: white;
    }

    /* EPISODES */
    .episode-grid {
      display: block;
      max-height: 80vh;
      overflow-y: auto;
      margin-top: 30px;
    }

    .episode-card {
      width: 85%;
      margin: 15px auto;
      padding: 20px;
      background: #1a1a1a;
      border: 3px solid #444;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: block;
      position: relative;
    }

    .episode-card.selected {
      border-color: #ff6b6b;
      background: #2a2a2a;
      transform: scale(1.02);
    }

    .episode-card.selected.button-focused {
      border-color: transparent;
    }

    .episode-card.downloaded {
      background: #2a2a2a;
      border-color: #28a745;
    }

    .episode-title {
      font-size: 22px;
      font-weight: bold;
      color: white;
      margin-bottom: 10px;
    }

    .episode-details {
      font-size: 16px;
      color: #bbb;
      margin-bottom: 10px;
    }

    .episode-status {
      font-size: 14px;
      margin-top: 5px;
      color: #28a745;
    }

    .episode-card button {
      background: #333;
      color: white;
      border: 2px solid #666;
      padding: 15px 25px;
      font-size: 18px;
      cursor: pointer;
      border-radius: 8px;
      min-width: 120px;
      transition: all 0.3s ease;
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
    }

    .episode-card button.selected {
      background: #ff6b6b;
      border-color: white;
      transform: translateY(-50%) scale(1.1);
    }

    /* Simple Dialog styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      align-items: center;
      justify-content: center;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background-color: #222;
      padding: 20px;
      border-radius: 5px;
      text-align: center;
      max-width: 400px;
      width: 80%;
      border: 2px solid white;
    }

    .modal-title {
      font-size: 20px;
      margin-bottom: 15px;
      color: white;
    }

    .modal-message {
      font-size: 16px;
      margin-bottom: 20px;
      color: #ccc;
    }

    .modal-buttons {
      display: flex;
      justify-content: center;
      gap: 15px;
    }

    .modal-button {
      padding: 10px 20px;
      font-size: 14px;
      border: 1px solid white;
      border-radius: 3px;
      cursor: pointer;
      background: transparent;
      color: white;
      min-width: 80px;
    }

    .modal-button.selected {
      background: white;
      color: black;
    }

    /* Loading Modal */
    .loading-modal {
      display: none;
      position: fixed;
      z-index: 2500;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      align-items: center;
      justify-content: center;
    }

    .loading-modal.show {
      display: flex;
    }

    .loading-content {
      text-align: center;
      color: white;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #333;
      border-top: 5px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      font-size: 24px;
      margin-bottom: 10px;
    }

    /* Video Player Overlay */
    .video-player {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: transparent; /* Make background transparent for video */
      z-index: 9999;
      pointer-events: none; /* Don't block video interaction */
    }

    .video-player.show {
      display: block; /* Changed from flex to block */
    }

    .video-controls {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      text-align: center;
      font-size: 18px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 30px;
      border-radius: 10px;
      pointer-events: auto; /* Allow interaction with controls */
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .video-message {
      margin-bottom: 10px;
      font-weight: bold;
    }

    .video-instructions {
      font-size: 14px;
      color: #ccc;
    }

    /* Video Player Controls Overlay */
    .video-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: transparent;
      z-index: 10000;
      display: none;
      flex-direction: column;
      pointer-events: none;
    }

    .video-overlay.show {
      display: flex;
    }

    .video-title {
      position: absolute;
      top: 40px;
      left: 40px;
      font-size: 28px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 25px;
      border-radius: 8px;
      pointer-events: all;
      z-index: 10001;
      backdrop-filter: blur(10px);
      transition: opacity 0.3s ease;
    }

    .video-title.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .video-controls-overlay {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 25px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 20px;
      transition: opacity 0.3s ease;
      pointer-events: all;
      z-index: 10001;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .video-controls-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .control-buttons-row {
      display: flex;
      align-items: center;
      gap: 25px;
    }

    .control-btn {
      background: rgba(255, 255, 255, 0.15);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      padding: 12px 15px;
      border-radius: 50%;
      font-size: 18px;
      cursor: pointer;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      backdrop-filter: blur(5px);
    }

    .control-btn.selected {
      background: rgba(255, 255, 255, 0.9);
      color: black;
      border-color: white;
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.5);
    }

    /* Audio Track Drawer */
    .audio-drawer {
      position: fixed;
      top: 0;
      right: -450px;
      width: 450px;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(20px);
      transition: right 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      z-index: 10002;
      padding: 80px 30px 30px 30px;
      box-sizing: border-box;
      border-left: 1px solid rgba(255, 255, 255, 0.1);
    }

    .audio-drawer.show {
      right: 0;
    }

    .audio-drawer-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 40px;
      padding-bottom: 20px;
      border-bottom: 2px solid rgba(255, 255, 255, 0.1);
    }

    .audio-drawer-title {
      font-size: 26px;
      color: white;
      font-weight: 600;
    }

    .audio-drawer-close {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .audio-drawer-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .audio-track-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
      max-height: calc(100% - 120px);
      overflow-y: auto;
    }

    .audio-track-item {
      background: rgba(255, 255, 255, 0.08);
      color: white;
      padding: 20px 25px;
      border-radius: 12px;
      border: 2px solid transparent;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .audio-track-item.selected {
      border-color: #ff6b6b;
      background: rgba(255, 107, 107, 0.1);
      transform: translateX(5px);
    }

    .audio-track-item.active {
      background: linear-gradient(135deg, #ff6b6b, #ff8e53);
      color: white;
      border-color: transparent;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
    }

    .audio-track-item:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateX(3px);
    }

    .audio-track-name {
      font-weight: 600;
      font-size: 18px;
    }

    .audio-track-details {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
    }

    /* Loading states */
    .audio-track-list.loading::before {
      content: "Loading audio tracks...";
      display: block;
      text-align: center;
      color: rgba(255, 255, 255, 0.6);
      font-style: italic;
      padding: 40px 20px;
    }

    /* Scrollbar styling for audio drawer */
    .audio-track-list::-webkit-scrollbar {
      width: 6px;
    }

    .audio-track-list::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }

    .audio-track-list::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }

    .audio-track-list::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }
  </style>
</head>
<body>
<div class="debug" id="debug">üîå Loading...</div>
<div id="app" class="screen"></div>

<!-- Modal for season download confirmation -->
<div id="confirmModal" class="modal">
  <div class="modal-content">
    <div class="modal-title" id="modalTitle">Download Season?</div>
    <div class="modal-message" id="modalMessage">Download all episodes?</div>
    <div class="modal-buttons">
      <button class="modal-button" id="confirmBtn">‚úÖ Download</button>
      <button class="modal-button" id="cancelBtn">‚ùå Cancel</button>
    </div>
  </div>
</div>

<!-- Season Download Progress Modal -->
<div id="seasonProgressModal" class="modal">
  <div class="modal-content" style="max-width: 500px;">
    <div class="modal-title">üì• Season Download</div>
    <div class="modal-message" id="seasonProgressMessage">Preparing download...</div>
    <div style="margin: 20px 0;">
      <div style="background: #333; height: 20px; border-radius: 10px; overflow: hidden;">
        <div id="seasonProgressBar" style="height: 100%; background: linear-gradient(90deg, #ff6b6b, #ff8e53); width: 0%; transition: width 0.3s ease;"></div>
      </div>
      <div id="seasonProgressText" style="text-align: center; margin-top: 10px; color: #ccc; font-size: 14px;">0 / 0 episodes</div>
    </div>
    <div class="modal-buttons">
      <button class="modal-button" id="cancelSeasonBtn">‚ùå Cancel</button>
      <button class="modal-button" id="closeProgressBtn" style="display: none;">‚úÖ Close</button>
    </div>
  </div>
</div>

<!-- Loading Modal -->
<div id="loadingModal" class="loading-modal">
  <div class="loading-content">
    <div class="loading-spinner"></div>
    <div class="loading-text" id="loadingText">Preparing Episode...</div>
    <div class="loading-details" id="loadingDetails">Starting download...</div>
  </div>
</div>

<!-- Next Episode Download Modal -->
<div id="nextEpisodeModal" class="loading-modal">
  <div class="loading-content">
    <div class="loading-spinner"></div>
    <div class="loading-text" id="nextEpisodeText">Downloading Next Episode...</div>
    <div class="loading-details" id="nextEpisodeDetails">Please wait while the next episode downloads</div>
    
    <!-- Download Progress Information -->
    <div style="margin: 20px 0; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
      <div id="downloadProgress" style="color: #ccc; font-size: 14px; margin-bottom: 10px;">
        Checking download status...
      </div>
      <div style="background: #333; height: 8px; border-radius: 4px; overflow: hidden; margin: 10px 0;">
        <div id="downloadProgressBar" style="height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); width: 0%; transition: width 0.3s ease;"></div>
      </div>
      <div style="display: flex; justify-content: space-between; font-size: 12px; color: #aaa;">
        <span id="downloadSize">Checking size...</span>
        <span id="downloadPercent">0%</span>
      </div>
    </div>
    
    <div style="margin-top: 15px; color: #ccc; font-size: 16px;">
      Press BACK button to return to episodes
    </div>
  </div>
</div>

<!-- Video Player Overlay -->
<div id="videoPlayer" class="video-player">
  <div class="video-controls">
    <div class="video-message" id="videoMessage">Playing Video</div>
    <div class="video-instructions">Press BACK button to return to episodes</div>
  </div>
</div>

<!-- Enhanced Video Controls Overlay -->
<div id="videoOverlay" class="video-overlay">
  <div class="video-title" id="videoTitle">Episode Title</div>
  <div class="video-controls-overlay" id="videoControlsOverlay">
    <button class="control-btn" id="audioTrackBtn">üéµ</button>
    <button class="control-btn" id="playPauseBtn">‚è∏Ô∏è</button>
    <button class="control-btn" id="stopBtn">‚èπÔ∏è</button>
  </div>
</div>

<!-- Audio Track Drawer -->
<div id="audioDrawer" class="audio-drawer">
  <div class="audio-drawer-header">
    <div class="audio-drawer-title">üéµ Audio Tracks</div>
    <button class="audio-drawer-close" id="audioDrawerClose">‚úï Close</button>
  </div>
  <div class="audio-track-list" id="audioTrackList">
    <!-- Audio tracks will be populated here -->
  </div>
</div>

<script>
var SERVER = "http://192.168.0.102:8000";
// Performance monitoring
var debugPerformance = function(operation, startTime) {
  var endTime = performance.now();
  var duration = endTime - startTime;
  if (duration > 100) { // Log operations taking more than 100ms
    debug("‚ö° " + operation + " took " + duration.toFixed(2) + "ms");
  }
};

var debug = function(msg) { 
  try {
    document.getElementById("debug").textContent = msg; 
  } catch (e) {
    console.error("Debug element not found:", e);
  }
};

var avplayObj = null;

var state = {
  view: "landing",
  seriesList: [],
  seasonList: [],
  episodeList: [],
  selectedSeries: 0,
  selectedSeason: 0,
  selectedEpisode: 0,
  focusMode: "card", // "card" or "button"
  modalVisible: false,
  modalSelectedButton: 0, // 0 for Download, 1 for Cancel
  enterKeyPressed: false,
  enterKeyTimer: null,
  longPressThreshold: 500, // 0.5 second for long press
  loadingVisible: false,
  videoPlaying: false, // Track if video is playing
  seasonDownload: {
    seriesName: null,
    seasonName: null,
    justOpened: false
  },
  videoPlayer: {
    visible: false,
    playing: false,
    currentTime: 0,
    duration: 0,
    selectedControl: 0, // 0=play/pause, 1=audio, 2=stop, 3=progress
    controlsVisible: true,
    controlsTimer: null,
    currentEpisode: null,
    audioTracks: [],
    currentAudioTrack: 0,
    audioDrawerVisible: false,
    selectedAudioTrack: 0,
    // Auto-play next episode features
    currentEpisodeIndex: -1,
    nextEpisodeAvailable: false,
    nextEpisodeDownloading: false,
    preDownloadTriggered: false,
    // Download progress tracking
    downloadProgress: {
      totalSize: 0,
      downloadedSize: 0,
      percentage: 0,
      episodeMsgId: null,
      progressInterval: null, // Track progress interval for cleanup
      downloadStartTime: null
    }
  },
  keyRepeat: {
    active: false,
    keyCode: null,
    timer: null,
    initialDelay: 300, // Initial delay before repeat starts (ms)
    repeatInterval: 80, // Interval between repeats (ms) - fast scrolling
    fastScrollStarted: false // Flag to track if fast scrolling actually started
  },
  // Global interval tracking for cleanup
  intervals: {
    nextEpisodeProgress: null,
    monitorDownload: null
  }
};

async function fetchSeries() {
  debug("üì° Loading series...");
  try {
    var res = await fetch(SERVER + "/catalog/series");
    state.seriesList = await res.json();
    renderLanding();
    debug("‚úÖ Series loaded");
  } catch (e) {
    debug("‚ùå Failed to fetch series");
  }
}

async function fetchSeasons() {
  debug("üì° Loading seasons...");
  
  // Aggressive state reset when switching series
  aggressiveStateReset();
  
  try {
    var selected = state.seriesList[state.selectedSeries];
    if (!selected) {
      throw new Error("No series selected");
    }
    
    var res = await fetch(SERVER + "/catalog/series/" + encodeURIComponent(selected.name));
    if (!res.ok) {
      throw new Error("Failed to fetch seasons: " + res.status);
    }
    
    state.seasonList = await res.json();
    state.selectedSeason = 0;
    state.selectedEpisode = 0;
    
    // Clear episode list completely
    state.episodeList = [];
    
    renderSeasons();
    debug("‚úÖ Seasons loaded");
    
  } catch (error) {
    debug("‚ùå Error fetching seasons: " + error.message);
    state.seasonList = [];
    state.selectedSeason = 0;
    state.selectedEpisode = 0;
    state.episodeList = [];
  }
}

async function fetchEpisodes() {
  var startTime = performance.now();
  try {
    var series = state.seriesList[state.selectedSeries];
    var season = state.seasonList[state.selectedSeason];
    
    if (!series || !season) {
      throw new Error("Invalid series or season data");
    }
    
    var res = await fetch(SERVER + "/catalog/series/" + encodeURIComponent(series.name) + "/" + encodeURIComponent(season));
    
    if (!res.ok) {
      throw new Error("Failed to fetch episodes: " + res.status);
    }
    
    var episodes = await res.json();
    
    // Enhance episodes with additional info if needed
    for (var i = 0; i < episodes.length; i++) {
      var ep = episodes[i];
      // Extract msg_id from URL if not already present
      if (!ep.msg_id) {
        var urlParts = parseMessageUrl(ep.url);
        if (urlParts) {
          ep.msg_id = urlParts.messageId;
        }
      }
    }
    
    state.episodeList = episodes;
    debugPerformance("fetchEpisodes", startTime);
    return episodes;
    
  } catch (error) {
    debug("‚ùå Error fetching episodes: " + error.message);
    state.episodeList = [];
    return [];
  }
}

function parseMessageUrl(url) {
  // Parse Telegram URL to extract message ID
  var publicMatch = url.match(/https:\/\/t\.me\/([^\/]+)\/(\d+)/);
  var privateMatch = url.match(/https:\/\/t\.me\/c\/(\d+)\/(\d+)/);
  
  if (publicMatch) {
    return {
      channel: publicMatch[1],
      messageId: parseInt(publicMatch[2])
    };
  } else if (privateMatch) {
    return {
      channel: parseInt(privateMatch[1]),
      messageId: parseInt(privateMatch[2])
    };
  }
  return null;
}

function renderLanding() {
  // Aggressive reset when going to landing
  aggressiveStateReset();
  
  state.view = "landing";
  state.episodeList = []; // Clear episode list when going to landing
  var app = document.getElementById("app");
  var cards = state.seriesList.map(function(s, i) {
    return '<div class="poster-card ' + (i === state.selectedSeries ? 'selected' : '') + '">' +
           '<img class="poster" src="' + SERVER + s.poster + '" />' +
           '<div style="margin-top:10px; font-size:22px; text-align:center;">' + s.name + '</div>' +
           '</div>';
  }).join("");
  app.innerHTML = 
    '<div class="title">üì∫ Select Series</div>' +
    '<div class="poster-grid">' + cards + '</div>';
    
  debug("üì∫ Landing rendered with aggressive state reset");
}

function renderSeasons() {
  // Aggressive reset before rendering seasons
  aggressiveStateReset();
  
  state.view = "seasons";
  state.episodeList = []; // Clear episode list when going to seasons
  var app = document.getElementById("app");
  var series = state.seriesList[state.selectedSeries];
  
  app.innerHTML = 
    '<div class="title">üéûÔ∏è ' + series.name + '</div>' +
    '<div class="season-grid" id="season-grid"></div>';
  
  var seasonGrid = document.getElementById("season-grid");
  
  for (var i = 0; i < state.seasonList.length; i++) {
    var season = state.seasonList[i];
    var seasonCard = document.createElement("div");
    seasonCard.className = "season-card" + (i === state.selectedSeason ? ' selected' : '');
    seasonCard.innerHTML = '<span>' + season + '</span>';
    
    // Add long press detection for download modal
    (function(index) {
      var longPressTimer = null;
      var longPressActive = false;
      
      seasonCard.addEventListener('mousedown', function() {
        longPressActive = false;
        longPressTimer = setTimeout(function() {
          longPressActive = true;
          state.selectedSeason = index;
          showSeasonDownloadModal();
        }, 1000);
      });
      
      seasonCard.addEventListener('mouseup', function() {
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
        
        if (!longPressActive) {
          // Regular click - navigate to episodes with state reset
          state.selectedSeason = index;
          state.selectedEpisode = 0;
          // Reset state before navigating to episodes
          aggressiveStateReset();
          renderEpisodes();
        }
      });
      
      seasonCard.addEventListener('mouseleave', function() {
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
        longPressActive = false;
      });
    })(i);
    
    seasonGrid.appendChild(seasonCard);
  }
  
  debug("üéûÔ∏è Seasons rendered with aggressive state reset");
}

async function renderEpisodes() {
  // Aggressive reset before rendering episodes
  aggressiveStateReset();
  
  state.view = "episodes";
  state.selectedEpisode = 0;
  state.focusMode = "card";

  var episodes = await fetchEpisodes();

  var container = document.getElementById("app");
  container.innerHTML = 
    '<div class="title">üé¨ Episodes</div>' +
    '<div class="episode-grid" id="episode-list"></div>';

  var list = document.getElementById("episode-list");

  // Optimized rendering - use DocumentFragment for better performance
  var fragment = document.createDocumentFragment();

  for (var i = 0; i < episodes.length; i++) {
    var ep = episodes[i];
    var isSelected = i === state.selectedEpisode;
    var isDownloaded = ep.downloaded || false;

    var card = document.createElement("div");
    var cardClass = "episode-card";
    if (isSelected) cardClass += " selected";
    if (isDownloaded) cardClass += " downloaded";
    
    card.className = cardClass;
    card.tabIndex = 0;
    card.setAttribute('data-episode-index', i);

    card.innerHTML = 
      '<div class="episode-title">' + escapeHtml(ep.title) + '</div>' +
      '<div class="episode-details">Episode ID: ' + ep.msg_id + '</div>' +
      '<div class="episode-status">' + (isDownloaded ? 'Downloaded' : 'Not Downloaded') + '</div>';

    // Use event delegation for better performance - attach listeners to parent
    card.onclick = createEpisodeClickHandler(i);

    // Add download button only for non-downloaded episodes
    if (!isDownloaded) {
      var downloadBtn = document.createElement("button");
      downloadBtn.textContent = "‚¨áÔ∏è Download";
      downloadBtn.setAttribute('data-episode-index', i);
      downloadBtn.onclick = createDownloadClickHandler(i);
      card.appendChild(downloadBtn);
    }

    fragment.appendChild(card);
  }

  // Single DOM operation for better performance
  list.appendChild(fragment);

  updateEpisodeFocus();
  scrollIntoViewIfNeeded(".episode-grid", state.selectedEpisode);
  
  debug("üé¨ Episodes rendered with aggressive state reset");
}

// Helper function to escape HTML for security
function escapeHtml(text) {
  var div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Optimized event handlers using closures
function createEpisodeClickHandler(index) {
  return function() {
    // Validate that we're still in the episodes view and have valid data
    if (state.view !== "episodes" || index >= state.episodeList.length || index < 0) {
      debug("‚ùå Invalid episode access - state mismatch");
      return;
    }
    
    var currentEpisode = state.episodeList[index];
    if (!currentEpisode) {
      debug("‚ùå Episode not found at index: " + index);
      return;
    }
    
    if (currentEpisode.downloaded) {
      playEpisode(currentEpisode);
    } else {
      downloadEpisode(currentEpisode);
    }
  };
}

function createDownloadClickHandler(index) {
  return function(e) {
    e.stopPropagation();
    // Validate state before accessing episode
    if (state.view !== "episodes" || index >= state.episodeList.length || index < 0) {
      debug("‚ùå Invalid button access - state mismatch");
      return;
    }
    var currentEpisode = state.episodeList[index];
    if (!currentEpisode) return;
    downloadEpisode(currentEpisode);
  };
}

function updateEpisodeFocus() {
  var list = document.getElementById("episode-list");
  if (!list) return;

  // Update all episode cards
  var children = list.children;
  for (var i = 0; i < children.length; i++) {
    var card = children[i];
    var isSelected = i === state.selectedEpisode;
    
    // Update card selection
    if (isSelected) {
      card.classList.add("selected");
      // If button is focused, remove card focus border
      if (state.focusMode === "button") {
        card.classList.add("button-focused");
      } else {
        card.classList.remove("button-focused");
      }
    } else {
      card.classList.remove("selected");
      card.classList.remove("button-focused");
    }
    
    // Update button focus if card has a download button
    var downloadBtn = card.querySelector("button");
    if (downloadBtn) {
      if (state.focusMode === "button" && isSelected) {
        downloadBtn.classList.add("selected");
      } else {
        downloadBtn.classList.remove("selected");
      }
    }
  }
}

async function playEpisode(episode) {
  debug("üé¨ Playing episode: " + episode.title);
  debug("üîç Episode msg_id: " + episode.msg_id);
  showLoadingModal("Preparing Video", "Getting stream URL...");
  
  // Find current episode index for auto-play feature
  state.videoPlayer.currentEpisodeIndex = -1;
  for (var i = 0; i < state.episodeList.length; i++) {
    if (state.episodeList[i].msg_id === episode.msg_id) {
      state.videoPlayer.currentEpisodeIndex = i;
      break;
    }
  }
  
  // Check and pre-download next episode if needed
  checkAndPreDownloadNextEpisode();
  
  try {
    // Get direct PixelDrain URL from server
    var streamUrlEndpoint = SERVER + "/get_stream_url/" + episode.msg_id;
    debug("üì° Requesting: " + streamUrlEndpoint);
    
    var response = await fetch(streamUrlEndpoint);
    
    if (!response.ok) {
      var errorText = await response.text();
      throw new Error("Server error " + response.status + ": " + errorText);
    }
    
    var streamData = await response.json();
    var streamUrl = streamData.stream_url;
    
    debug("üì° Got PixelDrain URL: " + streamUrl);
    hideLoadingModal();
    
    // Use AVPlay for Smart TV playback
    if (typeof webapis !== 'undefined' && webapis.avplay) {
      debug("üì∫ Using AVPlay for Samsung Smart TV");
      startVideoPlayback(episode, streamUrl);
    } else {
      debug("‚ö†Ô∏è AVPlay not available, using browser redirect");
      // Fallback to browser redirect for non-Samsung TVs
      setTimeout(function() {
        window.location.href = streamUrl;
      }, 1000);
    }
    
  } catch (error) {
    debug("‚ùå Error: " + error.message);
    hideLoadingModal();
    
    // Check if this episode is actually downloaded
    debug("üîç Checking episode download status...");
    if (!episode.downloaded) {
      debug("‚ö†Ô∏è Episode shows as not downloaded, triggering download");
      downloadEpisode(episode);
      return;
    }
    
    // Show detailed error to user
    showLoadingModal("Error", "Failed to load video. Check server logs for details.");
    setTimeout(function() {
      hideLoadingModal();
      // Refresh episodes to update status
      renderEpisodes();
    }, 3000);
  }
}

function startVideoPlayback(episode, videoUrl) {
  debug("üé¨ Starting video playback for: " + episode.title);
  debug("ÔøΩ Video URL: " + videoUrl);
  
  try {
    // Clean up any existing video
    if (avplayObj) {
      try {
        avplayObj.remove();
        avplayObj = null;
      } catch (e) {
        debug("üßπ Error removing old avplay object: " + e.message);
      }
    }
    
    // Stop any existing AVPlay
    if (typeof webapis !== 'undefined' && webapis.avplay) {
      try {
        webapis.avplay.stop();
        webapis.avplay.close();
      } catch (e) {
        // Ignore cleanup errors
      }
    }
    
    // Hide the main app UI and show video overlay
    document.getElementById("app").style.display = "none";
    document.getElementById("videoOverlay").classList.add("show");
    document.getElementById("videoTitle").textContent = episode.title;
    
    // Initialize video player state
    state.videoPlaying = true;
    state.videoPlayer.visible = true;
    state.videoPlayer.playing = true;
    state.videoPlayer.currentEpisode = episode;
    state.videoPlayer.selectedControl = 1; // Start with play/pause button selected
    state.videoPlayer.controlsVisible = false; // Start with controls hidden
    state.videoPlayer.audioTracks = [];
    state.videoPlayer.currentAudioTrack = 0;
    state.videoPlayer.audioDrawerVisible = false;
    
    // Initially hide controls and title
    document.getElementById("videoControlsOverlay").classList.add("hidden");
    document.getElementById("videoTitle").classList.add("hidden");
    
    updateVideoControls();
    
    // Create AVPlay object element for video display
    var obj = document.createElement('object');
    obj.setAttribute('type', 'application/avplayer');
    obj.style.position = 'fixed';
    obj.style.left = '0px';
    obj.style.top = '0px';
    obj.style.width = '100%';
    obj.style.height = '100%';
    obj.style.zIndex = '1000';
    obj.style.backgroundColor = 'black';
    document.body.appendChild(obj);
    avplayObj = obj;
    
    debug("üé¨ AVPlay object created");
    
    var avplay = webapis.avplay;
    
    // Close any existing playback
    try { 
      avplay.close(); 
    } catch (_) {}
    
    // Open the video URL
    debug("üöÄ Opening video URL");
    avplay.open(videoUrl);
    
    // Set display method to letterbox to maintain aspect ratio
    debug("üñ•Ô∏è Setting display method");
    avplay.setDisplayMethod("PLAYER_DISPLAY_MODE_LETTER_BOX");
    
    // Set up event listeners
    avplay.setListener({
      onbufferingstart: function() {
        debug("‚è≥ Buffering started");
      },
      onbufferingcomplete: function() {
        debug("‚úÖ Buffering complete");
      },
      oncurrentplaytime: function(currentTime) {
        state.videoPlayer.currentTime = currentTime / 1000; // Convert to seconds
        updateVideoProgress();
      },
      onstreamcompleted: function() {
        debug("‚úÖ Video completed");
        handleVideoCompletion();
      },
      onerror: function(error) {
        debug("‚ùå AVPlay error: " + JSON.stringify(error));
        stopVideo();
      },
      onstatechange: function(playerState) {
        debug("üîÑ Player state: " + playerState);
        state.videoPlayer.playing = (playerState === "PLAYING");
        updatePlayPauseButton();
      }
    });
    
    // Prepare and play
    avplay.prepareAsync(function() {
      try {
        debug("üé¨ Video prepared successfully");
        
        // Get video duration
        try {
          var duration = avplay.getDuration();
          state.videoPlayer.duration = duration / 1000; // Convert to seconds
          debug("üìè Video duration: " + state.videoPlayer.duration + "s");
          updateVideoProgress();
        } catch (e) {
          debug("‚ö†Ô∏è Could not get duration: " + e.message);
        }
        
        // Get audio tracks
        try {
          var audioTracks = avplay.getTotalTrackInfo();
          state.videoPlayer.audioTracks = audioTracks.filter(function(track) { return track.type === 'AUDIO'; });
          state.videoPlayer.currentAudioTrack = 0;
          populateAudioTracks();
          debug("üéµ Found " + state.videoPlayer.audioTracks.length + " audio tracks");
        } catch (e) {
          debug("üéµ No audio tracks info available: " + e.message);
          state.videoPlayer.audioTracks = [];
          populateAudioTracks();
        }
        
        // Start playback
        avplay.play();
        debug("‚ñ∂Ô∏è Video playback started successfully");
        updatePlayPauseButton();
        
      } catch (error) {
        debug("‚ùå Error in prepare callback: " + error.message);
        stopVideo();
      }
    }, function(error) {
      debug("‚ùå Failed to prepare video: " + JSON.stringify(error));
      stopVideo();
    });
    
  } catch (error) {
    debug("‚ùå Error starting video: " + error.message);
    stopVideo();
  }
}

function stopVideo() {
  debug("ÔøΩ Stopping video playback");
  
  if (typeof webapis !== 'undefined' && webapis.avplay) {
    try {
      webapis.avplay.stop();
      webapis.avplay.close();
      debug("üõë AVPlay stopped and closed");
    } catch (error) {
      debug("‚ö†Ô∏è Error stopping AVPlay: " + error.message);
    }
  }
  
  // Remove the AVPlay object element
  if (avplayObj) {
    try {
      avplayObj.remove();
      avplayObj = null;
      debug("üõë AVPlay object removed");
    } catch (e) {
      debug("‚ö†Ô∏è Error removing AVPlay object: " + e.message);
    }
  }
  
  // Show the main app UI
  document.getElementById("app").style.display = "block";
  state.videoPlaying = false;
  
  debug("‚èπÔ∏è Video playback stopped");
}

function downloadEpisode(episode) {
  debug("‚¨áÔ∏è Downloading episode: " + episode.title);
  showLoadingModal("Starting Download", "Uploading to PixelDrain...");
  
  fetch(SERVER + "/download?url=" + encodeURIComponent(episode.url))
    .then(function(res) { return res.json(); })
    .then(function(data) {
      if (data.status === "uploading" || data.status === "already_uploaded") {
        debug("‚úÖ Download/upload started");
        hideLoadingModal();
        // Refresh episodes to show updated status
        setTimeout(function() { renderEpisodes(); }, 1000);
      } else {
        debug("‚ùå Download failed: " + JSON.stringify(data));
        hideLoadingModal();
      }
    })
    .catch(function(err) {
      debug("‚ùå Error: " + err.message);
      hideLoadingModal();
    });
}

function showSeasonDownloadModal() {
  var series = state.seriesList[state.selectedSeries];
  var season = state.seasonList[state.selectedSeason];
  
  document.getElementById("modalTitle").textContent = "Download Season";
  document.getElementById("modalMessage").textContent = 
    'Download all episodes from "' + season + '" of ' + series.name + '?';
  
  var modal = document.getElementById("confirmModal");
  modal.classList.add("show");
  state.modalVisible = true;
  state.modalSelectedButton = 0;
  state.seasonDownload.seriesName = series.name;
  state.seasonDownload.seasonName = season;
  updateModalButtons();
  
  // Set a flag to prevent immediate modal closure
  state.seasonDownload.justOpened = true;
  setTimeout(function() {
    state.seasonDownload.justOpened = false;
  }, 200); // 200ms delay to prevent immediate closure
}

function hideSeasonDownloadModal() {
  var modal = document.getElementById("confirmModal");
  modal.classList.remove("show");
  state.modalVisible = false;
}

function downloadWholeSeason() {
  var seriesName = state.seasonDownload.seriesName;
  var seasonName = state.seasonDownload.seasonName;
  
  debug("‚¨áÔ∏è Starting season download: " + seasonName);
  
  fetch(SERVER + "/download/season?series_name=" + encodeURIComponent(seriesName) + "&season_name=" + encodeURIComponent(seasonName), {
    method: 'POST'
  })
  .then(function(response) { return response.json(); })
  .then(function(result) {
    if (result.status === "already_downloaded") {
      debug("‚úÖ All episodes already downloaded");
      showLoadingModal("Already Downloaded", "All episodes are already available!");
      setTimeout(function() {
        hideLoadingModal();
        if (state.view === "episodes") {
          renderEpisodes();
        }
      }, 2000);
    } else if (result.status === "queued") {
      debug("‚úÖ Season download started in background: " + seasonName);
      // Show brief notification and continue using the app
      showLoadingModal("Background Download Started", 
        "Season '" + seasonName + "' is downloading in background (" + result.episodes_to_download + " episodes). You can continue using the app.");
      setTimeout(function() {
        hideLoadingModal();
        // Don't store season_id since we're not tracking progress in UI
      }, 3000);
    }
  })
  .catch(function(error) {
    debug("‚ùå Season download error: " + error.message);
    showLoadingModal("Error", "Failed to start season download");
    setTimeout(function() { hideLoadingModal(); }, 3000);
  });
}

function updateModalButtons() {
  var confirmBtn = document.getElementById("confirmBtn");
  var cancelBtn = document.getElementById("cancelBtn");
  
  if (state.modalSelectedButton === 0) {
    confirmBtn.classList.add("selected");
    cancelBtn.classList.remove("selected");
  } else {
    confirmBtn.classList.remove("selected");
    cancelBtn.classList.add("selected");
  }
}

// Missing functions that need to be implemented

function showLoadingModal(title, details) {
  document.getElementById("loadingText").textContent = title || "Loading...";
  document.getElementById("loadingDetails").textContent = details || "";
  
  var modal = document.getElementById("loadingModal");
  modal.classList.add("show");
  state.loadingVisible = true;
}

function hideLoadingModal() {
  var modal = document.getElementById("loadingModal");
  modal.classList.remove("show");
  state.loadingVisible = false;
}

function scrollIntoViewIfNeeded(containerSelector, index) {
  var container = document.querySelector(containerSelector);
  if (!container) return;
  var item = container.children[index];
  if (item) item.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "nearest" });
}

function goBack() {
  debug("üîô Go Back");
  
  // Clean up any active intervals when navigating
  cleanupIntervals();
  
  if (state.loadingVisible) {
    hideLoadingModal();
  }
  
  if (state.view === "episodes") {
    state.selectedEpisode = 0;
    state.focusMode = "card";
    state.episodeList = []; // Clear episode list when going back
    renderSeasons();
  } else if (state.view === "seasons") {
    state.episodeList = []; // Clear episode list when going back
    renderLanding();
  }
}

// Enhanced memory cleanup function with aggressive state reset
function cleanupIntervals() {
  // Clear all tracked intervals
  if (state.intervals.nextEpisodeProgress) {
    clearInterval(state.intervals.nextEpisodeProgress);
    state.intervals.nextEpisodeProgress = null;
  }
  
  if (state.intervals.monitorDownload) {
    clearInterval(state.intervals.monitorDownload);
    state.intervals.monitorDownload = null;
  }
  
  if (state.videoPlayer.downloadProgress.progressInterval) {
    clearInterval(state.videoPlayer.downloadProgress.progressInterval);
    state.videoPlayer.downloadProgress.progressInterval = null;
  }
  
  // Clear key repeat timer
  if (state.keyRepeat.timer) {
    clearTimeout(state.keyRepeat.timer);
    state.keyRepeat.timer = null;
    state.keyRepeat.active = false;
  }
  
  // Clear video controls timer
  if (state.videoPlayer.controlsTimer) {
    clearTimeout(state.videoPlayer.controlsTimer);
    state.videoPlayer.controlsTimer = null;
  }
  
  // Clear enter key timer
  if (state.enterKeyTimer) {
    clearTimeout(state.enterKeyTimer);
    state.enterKeyTimer = null;
    state.enterKeyPressed = false;
  }
}

// Aggressive state reset function
function aggressiveStateReset() {
  debug("üîÑ Performing aggressive state reset...");
  
  // Clean up all intervals and timers first
  cleanupIntervals();
  
  // Force hide all modals
  hideAllModals();
  
  // Reset modal states
  state.modalVisible = false;
  state.modalSelectedButton = 0;
  state.loadingVisible = false;
  
  // Reset season download state
  state.seasonDownload = {
    seriesName: null,
    seasonName: null,
    justOpened: false
  };
  
  // Reset key states
  state.enterKeyPressed = false;
  state.keyRepeat = {
    active: false,
    keyCode: null,
    timer: null,
    initialDelay: 300,
    repeatInterval: 80,
    fastScrollStarted: false
  };
  
  // Reset video player states (but don't interrupt actual video playback)
  if (!state.videoPlaying) {
    state.videoPlayer.nextEpisodeDownloading = false;
    state.videoPlayer.preDownloadTriggered = false;
    state.videoPlayer.downloadProgress = {
      totalSize: 0,
      downloadedSize: 0,
      percentage: 0,
      episodeMsgId: null,
      progressInterval: null,
      downloadStartTime: null
    };
  }
  
  // Clear any lingering DOM states
  clearDOMStates();
  
  debug("‚úÖ Aggressive state reset completed");
}

// Function to hide all modals forcefully
function hideAllModals() {
  var modals = [
    'confirmModal',
    'seasonProgressModal', 
    'loadingModal',
    'nextEpisodeModal'
  ];
  
  modals.forEach(function(modalId) {
    var modal = document.getElementById(modalId);
    if (modal) {
      modal.classList.remove('show');
    }
  });
  
  // Hide audio drawer if open
  var audioDrawer = document.getElementById('audioDrawer');
  if (audioDrawer) {
    audioDrawer.classList.remove('show');
  }
  
  // Reset video overlay states
  if (!state.videoPlaying) {
    var videoOverlay = document.getElementById('videoOverlay');
    if (videoOverlay) {
      videoOverlay.classList.remove('show');
    }
  }
}

// Clear any lingering DOM states
function clearDOMStates() {
  // Remove any temporary classes or states from DOM elements
  var cards = document.querySelectorAll('.season-card, .episode-card, .poster-card');
  cards.forEach(function(card) {
    // Reset any transition states
    card.style.transition = '';
  });
}

// Video Player Control Functions
function togglePlayPause() {
  if (typeof webapis === 'undefined' || !webapis.avplay) return;
  
  try {
    var avplay = webapis.avplay;
    var currentState = avplay.getState();
    
    if (currentState === "PLAYING") {
      avplay.pause();
      state.videoPlayer.playing = false;
      debug("‚è∏Ô∏è Video paused");
    } else if (currentState === "PAUSED") {
      avplay.play();
      state.videoPlayer.playing = true;
      debug("‚ñ∂Ô∏è Video resumed");
    }
    updatePlayPauseButton();
    showVideoControls();
  } catch (error) {
    debug("‚ùå Error toggling play/pause: " + error.message);
  }
}

function seekVideo(seconds) {
  if (typeof webapis === 'undefined' || !webapis.avplay) return;
  
  try {
    var avplay = webapis.avplay;
    var currentState = avplay.getState();
    
    if (currentState === "PLAYING" || currentState === "PAUSED") {
      var seekMs = Math.abs(seconds) * 1000; // Convert to milliseconds
      
      if (seconds > 0) {
        avplay.jumpForward(seekMs);
        debug("‚è© Seek forward " + Math.abs(seconds) + "s");
      } else {
        avplay.jumpBackward(seekMs);
        debug("‚è™ Seek backward " + Math.abs(seconds) + "s");
      }
    }
  } catch (error) {
    debug("‚ùå Error seeking: " + error.message);
  }
}

function hideVideoControls() {
  var controls = document.getElementById("videoControlsOverlay");
  var title = document.getElementById("videoTitle");
  
  controls.classList.add("hidden");
  title.classList.add("hidden");
  state.videoPlayer.controlsVisible = false;
  
  // Clear any existing timer
  if (state.videoPlayer.controlsTimer) {
    clearTimeout(state.videoPlayer.controlsTimer);
    state.videoPlayer.controlsTimer = null;
  }
}

function updatePlayPauseButton() {
  var btn = document.getElementById("playPauseBtn");
  if (state.videoPlayer.playing) {
    btn.textContent = "‚è∏Ô∏è";
  } else {
    btn.textContent = "‚ñ∂Ô∏è";
  }
}

function updateVideoControls() {
  var buttons = ["audioTrackBtn", "playPauseBtn", "stopBtn"];
  
  // Update button selection
  for (var i = 0; i < buttons.length; i++) {
    var btn = document.getElementById(buttons[i]);
    if (i === state.videoPlayer.selectedControl) {
      btn.classList.add("selected");
    } else {
      btn.classList.remove("selected");
    }
  }
}

function updateVideoProgress() {
  // Progress tracking removed - no progress bar in new UI
}

function showVideoControls() {
  var controls = document.getElementById("videoControlsOverlay");
  var title = document.getElementById("videoTitle");
  
  controls.classList.remove("hidden");
  title.classList.remove("hidden");
  state.videoPlayer.controlsVisible = true;
  
  // Auto-hide controls after 4 seconds
  if (state.videoPlayer.controlsTimer) {
    clearTimeout(state.videoPlayer.controlsTimer);
  }
  state.videoPlayer.controlsTimer = setTimeout(function() {
    if (!state.videoPlayer.audioDrawerVisible) { // Don't hide if drawer is open
      controls.classList.add("hidden");
      title.classList.add("hidden");
      state.videoPlayer.controlsVisible = false;
    }
  }, 4000);
}

function populateAudioTracks() {
  var audioTrackList = document.getElementById("audioTrackList");
  audioTrackList.innerHTML = "";
  
  if (state.videoPlayer.audioTracks.length === 0) {
    var noTracks = document.createElement("div");
    noTracks.className = "audio-track-item";
    noTracks.innerHTML = 
      '<div class="audio-track-name">No Audio Tracks</div>' +
      '<div class="audio-track-details">No additional audio tracks available</div>';
    audioTrackList.appendChild(noTracks);
    return;
  }
  
  for (var i = 0; i < state.videoPlayer.audioTracks.length; i++) {
    var track = state.videoPlayer.audioTracks[i];
    var trackItem = document.createElement("div");
    trackItem.className = "audio-track-item";
    if (i === state.videoPlayer.currentAudioTrack) {
      trackItem.classList.add("active");
    }
    
    var trackName = track.language || track.extra_info || ("Track " + (i + 1));
    var trackDetails = [];
    
    if (track.language) trackDetails.push("Language: " + track.language);
    if (track.extra_info) trackDetails.push(track.extra_info);
    if (track.channels) trackDetails.push(track.channels + " channels");
    
    trackItem.innerHTML = 
      '<div class="audio-track-name">' + trackName + '</div>' +
      '<div class="audio-track-details">' + (trackDetails.join(' ‚Ä¢ ') || 'Default audio track') + '</div>';
    
    (function(index) {
      trackItem.onclick = function() { selectAudioTrack(index); };
    })(i);
    
    audioTrackList.appendChild(trackItem);
  }
}

function selectAudioTrack(index) {
  if (typeof webapis === 'undefined' || !webapis.avplay) return;
  
  try {
    var avplay = webapis.avplay;
    var track = state.videoPlayer.audioTracks[index];
    
    avplay.setSelectTrack('AUDIO', index);
    state.videoPlayer.currentAudioTrack = index;
    
    // Update UI
    populateAudioTracks();
    debug("üéµ Changed to audio track: " + (track.language || track.extra_info || ("Track " + (index + 1))));
    
    // Close drawer after selection
    setTimeout(function() {
      hideAudioDrawer();
    }, 800);
  } catch (error) {
    debug("‚ùå Error changing audio track: " + error.message);
  }
}

function showAudioDrawer() {
  document.getElementById("audioDrawer").classList.add("show");
  state.videoPlayer.audioDrawerVisible = true;
  state.videoPlayer.selectedAudioTrack = state.videoPlayer.currentAudioTrack;
  updateAudioTrackSelection();
  
  // Keep controls visible while drawer is open
  showVideoControls();
}

function hideAudioDrawer() {
  document.getElementById("audioDrawer").classList.remove("show");
  state.videoPlayer.audioDrawerVisible = false;
}

function updateAudioTrackSelection() {
  var trackItems = document.querySelectorAll(".audio-track-item");
  for (var i = 0; i < trackItems.length; i++) {
    var item = trackItems[i];
    if (i === state.videoPlayer.selectedAudioTrack) {
      item.classList.add("selected");
    } else {
      item.classList.remove("selected");
    }
  }
}

// Key handling functions
function handleKey(code) {
  debug("key: " + code);
  
  // Handle video player controls
  if (state.videoPlaying) {
    // Handle audio drawer navigation
    if (state.videoPlayer.audioDrawerVisible) {
      if (code === 38) { // Up arrow
        state.videoPlayer.selectedAudioTrack = Math.max(0, state.videoPlayer.selectedAudioTrack - 1);
        updateAudioTrackSelection();
      } else if (code === 40) { // Down arrow
        state.videoPlayer.selectedAudioTrack = Math.min(state.videoPlayer.audioTracks.length - 1, state.videoPlayer.selectedAudioTrack + 1);
        updateAudioTrackSelection();
      } else if (code === 13) { // Enter - select audio track
        selectAudioTrack(state.videoPlayer.selectedAudioTrack);
      } else if (code === 10009 || code === 37) { // Back or Left arrow - close drawer
        hideAudioDrawer();
      }
      return;
    }
    
    // Handle navigation controls
    if (code === 38) { // Up arrow - hide controls
      if (state.videoPlayer.controlsVisible) {
        hideVideoControls();
      }
    } else if (code === 40) { // Down arrow - show controls and navigate
      showVideoControls();
      state.videoPlayer.selectedControl = Math.min(2, state.videoPlayer.selectedControl + 1);
      updateVideoControls();
    } else if (code === 37 || code === 39) { // Left/Right arrows
      if (state.videoPlayer.controlsVisible) {
        // Controls visible - navigate between buttons
        if (code === 37) { // Left arrow
          state.videoPlayer.selectedControl = Math.max(0, state.videoPlayer.selectedControl - 1);
        } else { // Right arrow
          state.videoPlayer.selectedControl = Math.min(2, state.videoPlayer.selectedControl + 1);
        }
        updateVideoControls();
        showVideoControls(); // Reset timer
      } else {
        // Controls hidden - seek video (don't show controls)
        if (code === 37) { // Left arrow - rewind
          seekVideo(-10);
        } else { // Right arrow - forward
          seekVideo(10);
        }
      }
    } else if (code === 13) { // Enter
      if (state.videoPlayer.controlsVisible) {
        // Controls visible - activate selected button
        switch (state.videoPlayer.selectedControl) {
          case 0: // Audio Track
            if (state.videoPlayer.audioTracks.length > 0) {
              showAudioDrawer();
            } else {
              debug("üéµ No audio tracks available");
            }
            break;
          case 1: // Play/Pause
            togglePlayPause();
            break;
          case 2: // Stop
            stopVideo();
            break;
        }
      } else {
        // Controls hidden - toggle play/pause
        togglePlayPause();
      }
    } else if (code === 10009) { // Back button
      stopVideo();
    } else if (code === 417) { // Fast forward button (if available)
      seekVideo(30);
    } else if (code === 412) { // Rewind button (if available)
      seekVideo(-30);
    } else if (code === 19) { // Pause button (if available)
      if (state.videoPlayer.playing) togglePlayPause();
    } else if (code === 415) { // Play button (if available)
      if (!state.videoPlayer.playing) togglePlayPause();
    }
    return;
  }
  
  // Don't handle UP/DOWN keys here if fast scrolling is active
  if ((code === 38 || code === 40) && state.keyRepeat.active) {
    return;
  }
  
  // Handle modal navigation
  if (state.modalVisible) {
    // Don't handle Enter key if modal was just opened
    if (code === 13 && state.seasonDownload.justOpened) {
      return;
    }
    
    if (code === 37) { // Left arrow
      state.modalSelectedButton = 0; // Download
      updateModalButtons();
    } else if (code === 39) { // Right arrow
      state.modalSelectedButton = 1; // Cancel
      updateModalButtons();
    } else if (code === 13) { // Enter
      if (state.modalSelectedButton === 0) {
        hideSeasonDownloadModal();
        downloadWholeSeason();
      } else {
        hideSeasonDownloadModal();
      }
    } else if (code === 10009) { // Back button
      hideSeasonDownloadModal();
    }
    return;
  }
  
  // Handle loading modal (only back button)
  if (state.loadingVisible) {
    if (code === 10009) { // Back button - cancel loading
      debug("üö´ User cancelled loading");
      hideLoadingModal();
    }
    return;
  }
  
  // Handle next episode download modal
  if (document.getElementById("nextEpisodeModal").classList.contains("show")) {
    if (code === 10009) { // Back button - return to episodes
      debug("üö´ User cancelled next episode download");
      hideNextEpisodeDownloadModal();
      renderEpisodes();
    }
    return;
  }
  
  if (state.view === "landing") {
    if (code === 37) state.selectedSeries = (state.selectedSeries - 1 + state.seriesList.length) % state.seriesList.length;
    else if (code === 39) state.selectedSeries = (state.selectedSeries + 1) % state.seriesList.length;
    else if (code === 13) {
      // Aggressive state reset before navigating to seasons
      aggressiveStateReset();
      fetchSeasons();
    }
    renderLanding();
  } else if (state.view === "seasons") {
    if (code === 37 || code === 38) state.selectedSeason = (state.selectedSeason - 1 + state.seasonList.length) % state.seasonList.length;
    else if (code === 39 || code === 40) state.selectedSeason = (state.selectedSeason + 1) % state.seasonList.length;
    else if (code === 13) {
      // Handle in keydown/keyup for long press detection
      return;
    }
    else if (code === 10009) { // Back button
      goBack();
      return;
    }
    renderSeasons();
  } else if (state.view === "episodes") {
    var listLength = state.episodeList.length;

    if (state.focusMode === "card") {
      if (code === 38 && state.selectedEpisode > 0) {
        state.selectedEpisode--;
        updateEpisodeFocus();
        scrollIntoViewIfNeeded(".episode-grid", state.selectedEpisode);
      } else if (code === 40 && state.selectedEpisode < listLength - 1) {
        state.selectedEpisode++;
        updateEpisodeFocus();
        scrollIntoViewIfNeeded(".episode-grid", state.selectedEpisode);
      } else if (code === 39) {
        // Right arrow switches focus to button (only if episode has download button)
        if (state.selectedEpisode >= 0 && state.selectedEpisode < state.episodeList.length) {
          var ep = state.episodeList[state.selectedEpisode];
          if (ep && !ep.downloaded) {
            state.focusMode = "button";
            updateEpisodeFocus();
          }
        }
      } else if (code === 13) {
        // Enter key on episode
        if (state.selectedEpisode >= 0 && state.selectedEpisode < state.episodeList.length) {
          var ep = state.episodeList[state.selectedEpisode];
          if (ep) {
            if (ep.downloaded) {
              playEpisode(ep);
            } else {
              downloadEpisode(ep);
            }
          }
        }
      } else if (code === 10009) { // Back button
        goBack();
        return;
      }
    } else if (state.focusMode === "button") {
      if (code === 38 && state.selectedEpisode > 0) {
        state.selectedEpisode--;
        updateEpisodeFocus();
        scrollIntoViewIfNeeded(".episode-grid", state.selectedEpisode);
      } else if (code === 40 && state.selectedEpisode < listLength - 1) {
        state.selectedEpisode++;
        updateEpisodeFocus();
        scrollIntoViewIfNeeded(".episode-grid", state.selectedEpisode);
      } else if (code === 37) {
        // Left arrow goes back to card
        state.focusMode = "card";
        updateEpisodeFocus();
      } else if (code === 13) {
        // Enter key on download button
        if (state.selectedEpisode >= 0 && state.selectedEpisode < state.episodeList.length) {
          var ep = state.episodeList[state.selectedEpisode];
          if (ep) {
            downloadEpisode(ep);
          }
        }
      } else if (code === 10009) { // Back button
        goBack();
        return;
      }
    }
  }
}

function handleKeyDown(code) {
  // Handle long press detection for Enter key in seasons view
  if (state.view === "seasons" && code === 13 && !state.enterKeyPressed) {
    state.enterKeyPressed = true;
    state.enterKeyTimer = setTimeout(function() {
      // Long press detected
      debug("Long press detected - showing download dialog");
      showSeasonDownloadModal();
      state.enterKeyPressed = false;
      
      // Set a flag to prevent immediate modal closure
      state.seasonDownload.justOpened = true;
      setTimeout(function() {
        state.seasonDownload.justOpened = false;
      }, 100); // 100ms delay to prevent immediate closure
    }, state.longPressThreshold);
    return;
  }

  // Handle key repeat for fast scrolling
  var isNavigationKey = (code === 37 || code === 38 || code === 39 || code === 40);
  
  if (isNavigationKey && !state.modalVisible && !state.loadingVisible) {
    if (!state.keyRepeat.active) {
      // Start key repeat
      state.keyRepeat.active = true;
      state.keyRepeat.keyCode = code;
      state.keyRepeat.fastScrollStarted = false;
      
      // Set initial delay timer
      state.keyRepeat.timer = setTimeout(function() {
        state.keyRepeat.fastScrollStarted = true;
        startFastScroll(code);
      }, state.keyRepeat.initialDelay);
    }
  }
}

function handleKeyUp(code) {
  // Handle short press for Enter key in seasons view
  if (state.view === "seasons" && code === 13 && state.enterKeyPressed) {
    if (state.enterKeyTimer) {
      clearTimeout(state.enterKeyTimer);
      state.enterKeyTimer = null;
    }
    state.enterKeyPressed = false;
    
    // Don't navigate if modal was just opened
    if (state.seasonDownload.justOpened) {
      return;
    }
    
    // Short press - go to episodes
    state.selectedEpisode = 0;
    // Aggressive state reset before navigating to episodes
    aggressiveStateReset();
    renderEpisodes();
    return;
  }

  // Stop key repeat when key is released
  var isNavigationKey = (code === 37 || code === 38 || code === 39 || code === 40);
  
  if (isNavigationKey && state.keyRepeat.active && state.keyRepeat.keyCode === code) {
    stopKeyRepeat();
  }
}

function startFastScroll(code) {
  if (!state.keyRepeat.active || state.keyRepeat.keyCode !== code) {
    return;
  }
  
  // Execute the navigation action
  executeFastNavigation(code);
  
  // Set up the repeat timer
  state.keyRepeat.timer = setTimeout(function() {
    startFastScroll(code);
  }, state.keyRepeat.repeatInterval);
}

function stopKeyRepeat() {
  state.keyRepeat.active = false;
  state.keyRepeat.fastScrollStarted = false;
  state.keyRepeat.keyCode = null;
  
  if (state.keyRepeat.timer) {
    clearTimeout(state.keyRepeat.timer);
    state.keyRepeat.timer = null;
  }
}

function executeFastNavigation(code) {
  if (state.view === "landing") {
    if (code === 37) {
      state.selectedSeries = (state.selectedSeries - 1 + state.seriesList.length) % state.seriesList.length;
      renderLanding();
    } else if (code === 39) {
      state.selectedSeries = (state.selectedSeries + 1) % state.seriesList.length;
      renderLanding();
    }
  } else if (state.view === "seasons") {
    if (code === 37 || code === 38) {
      state.selectedSeason = (state.selectedSeason - 1 + state.seasonList.length) % state.seasonList.length;
      renderSeasons();
    } else if (code === 39 || code === 40) {
      state.selectedSeason = (state.selectedSeason + 1) % state.seasonList.length;
      renderSeasons();
    }
  } else if (state.view === "episodes") {
    var listLength = state.episodeList.length;
    
    if (state.focusMode === "card" || state.focusMode === "button") {
      if (code === 38 && state.selectedEpisode > 0) {
        state.selectedEpisode--;
        updateEpisodeFocus();
        scrollIntoViewIfNeeded(".episode-grid", state.selectedEpisode);
      } else if (code === 40 && state.selectedEpisode < listLength - 1) {
        state.selectedEpisode++;
        updateEpisodeFocus();
        scrollIntoViewIfNeeded(".episode-grid", state.selectedEpisode);
      }
    }
  }
}

// Auto-play next episode functions
function checkAndPreDownloadNextEpisode() {
  var nextIndex = state.videoPlayer.currentEpisodeIndex + 1;
  
  if (nextIndex >= state.episodeList.length) {
    debug("üì∫ No next episode available (end of season)");
    state.videoPlayer.nextEpisodeAvailable = false;
    return;
  }
  
  var nextEpisode = state.episodeList[nextIndex];
  if (!nextEpisode) {
    debug("‚ùå Next episode not found in list");
    state.videoPlayer.nextEpisodeAvailable = false;
    return;
  }
  
  state.videoPlayer.nextEpisodeAvailable = true;
  
  if (nextEpisode.downloaded) {
    debug("‚úÖ Next episode already downloaded: " + nextEpisode.title);
    state.videoPlayer.nextEpisodeDownloading = false;
  } else {
    debug("‚¨áÔ∏è Pre-downloading next episode: " + nextEpisode.title);
    state.videoPlayer.nextEpisodeDownloading = true;
    state.videoPlayer.preDownloadTriggered = true;
    
    // Trigger download for next episode
    fetch(SERVER + "/download?url=" + encodeURIComponent(nextEpisode.url))
      .then(function(res) { return res.json(); })
      .then(function(data) {
        if (data.status === "uploading" || data.status === "already_uploaded") {
          debug("‚úÖ Pre-download started for next episode");
          // Monitor download progress
          monitorNextEpisodeDownload(nextEpisode);
        } else {
          debug("‚ùå Pre-download failed: " + JSON.stringify(data));
          state.videoPlayer.nextEpisodeDownloading = false;
        }
      })
      .catch(function(err) {
        debug("‚ùå Pre-download error: " + err.message);
        state.videoPlayer.nextEpisodeDownloading = false;
      });
  }
}

function monitorNextEpisodeDownload(nextEpisode) {
  // Check download status every 3 seconds
  var checkInterval = setInterval(function() {
    // Refresh episode list to check if download completed
    fetchEpisodes().then(function(episodes) {
      state.episodeList = episodes;
      
      // Find the next episode in updated list
      var nextIndex = state.videoPlayer.currentEpisodeIndex + 1;
      if (nextIndex < episodes.length) {
        var updatedNextEpisode = episodes[nextIndex];
        if (updatedNextEpisode.downloaded) {
          debug("‚úÖ Next episode download completed: " + updatedNextEpisode.title);
          state.videoPlayer.nextEpisodeDownloading = false;
          clearInterval(checkInterval);
        }
      }
    }).catch(function(error) {
      debug("‚ùå Error checking next episode status: " + error.message);
    });
  }, 3000);
  
  // Stop monitoring after 10 minutes
  setTimeout(function() {
    clearInterval(checkInterval);
    state.videoPlayer.nextEpisodeDownloading = false;
  }, 600000); // 10 minutes
}

function handleVideoCompletion() {
  debug("üé¨ Video completed - checking for next episode");
  
  if (!state.videoPlayer.nextEpisodeAvailable) {
    debug("üì∫ No more episodes, stopping playback");
    stopVideo();
    return;
  }
  
  var nextIndex = state.videoPlayer.currentEpisodeIndex + 1;
  var nextEpisode = state.episodeList[nextIndex];
  
  if (!nextEpisode) {
    debug("‚ùå Next episode not found");
    stopVideo();
    return;
  }
  
  // Check if next episode is downloaded
  if (nextEpisode.downloaded) {
    debug("üé¨ Auto-playing next episode: " + nextEpisode.title);
    // Auto-play next episode
    setTimeout(function() {
      stopVideo();
      setTimeout(function() {
        playEpisode(nextEpisode);
      }, 500);
    }, 1000);
  } else if (state.videoPlayer.nextEpisodeDownloading) {
    debug("‚è≥ Next episode still downloading, showing progress modal");
    // Show download progress modal
    stopVideo();
    showNextEpisodeDownloadModal(nextEpisode);
  } else {
    debug("‚ùå Next episode not available, stopping playback");
    stopVideo();
  }
}

function showNextEpisodeDownloadModal(nextEpisode) {
  debug("‚è≥ Showing next episode download modal");
  
  // Clean up any existing progress monitoring
  if (state.intervals.nextEpisodeProgress) {
    clearInterval(state.intervals.nextEpisodeProgress);
    state.intervals.nextEpisodeProgress = null;
  }
  
  document.getElementById("nextEpisodeText").textContent = "Downloading Next Episode...";
  document.getElementById("nextEpisodeDetails").textContent = "Episode: " + nextEpisode.title;
  
  // Initialize progress display
  updateDownloadProgressDisplay(0, 0, 0);
  
  var modal = document.getElementById("nextEpisodeModal");
  modal.classList.add("show");
  state.videoPlayer.nextEpisodeDownloading = true;
  
  // Reset progress tracking with episode msg_id
  state.videoPlayer.downloadProgress = {
    totalSize: 0,
    downloadedSize: 0,
    percentage: 0,
    episodeMsgId: nextEpisode.msg_id,
    startTime: Date.now()
  };
  
  // Get real file info from server first
  fetchEpisodeFileSize(nextEpisode).then(function(fileInfo) {
    if (fileInfo && fileInfo.file_size) {
      nextEpisode.file_size = fileInfo.file_size;
      debug("üìè Got real file size: " + (fileInfo.file_size / (1024*1024)).toFixed(1) + " MB");
    }
    
    // Start monitoring real progress
    getRealDownloadProgress(nextEpisode);
  });
  
  // Monitor download progress with server data
  state.intervals.nextEpisodeProgress = setInterval(function() {
    // Get real progress from server
    getRealDownloadProgress(nextEpisode);
    
    // Check if download completed
    fetchEpisodes().then(function(episodes) {
      state.episodeList = episodes;
      
      var nextIndex = state.videoPlayer.currentEpisodeIndex + 1;
      if (nextIndex < episodes.length) {
        var updatedNextEpisode = episodes[nextIndex];
        if (updatedNextEpisode.downloaded) {
          debug("‚úÖ Next episode ready! Auto-playing...");
          if (state.intervals.nextEpisodeProgress) {
            clearInterval(state.intervals.nextEpisodeProgress);
            state.intervals.nextEpisodeProgress = null;
          }
          hideNextEpisodeDownloadModal();
          
          // Auto-play next episode
          setTimeout(function() {
            playEpisode(updatedNextEpisode);
          }, 500);
        }
      }
    }).catch(function(error) {
      debug("‚ùå Error checking download progress: " + error.message);
    });
  }, 5000); // Check every 5 seconds for real progress
  
  // No timeout - let download complete regardless of file size
}

function fetchEpisodeFileSize(episode) {
  // Get file size information from server
  return fetch(SERVER + "/download/file_info/" + episode.msg_id)
    .then(function(response) { return response.json(); })
    .then(function(fileInfo) {
      if (fileInfo.status === "found") {
        return fileInfo;
      } else {
        debug("‚ö†Ô∏è Could not get file size from server: " + fileInfo.note);
        return null;
      }
    })
    .catch(function(error) {
      debug("‚ùå Error fetching file size: " + error.message);
      return null;
    });
}

function hideNextEpisodeDownloadModal() {
  var modal = document.getElementById("nextEpisodeModal");
  modal.classList.remove("show");
  state.videoPlayer.nextEpisodeDownloading = false;
  
  // Clean up progress interval
  if (state.intervals.nextEpisodeProgress) {
    clearInterval(state.intervals.nextEpisodeProgress);
    state.intervals.nextEpisodeProgress = null;
  }
}

function updateDownloadProgressDisplay(downloadedSize, totalSize, percentage) {
  // Update progress bar
  var progressBar = document.getElementById("downloadProgressBar");
  if (progressBar) {
    progressBar.style.width = percentage + "%";
  }
  
  // Update size display
  var sizeElement = document.getElementById("downloadSize");
  if (sizeElement) {
    var downloadedMB = (downloadedSize / (1024 * 1024)).toFixed(1);
    var totalMB = (totalSize / (1024 * 1024)).toFixed(1);
    sizeElement.textContent = downloadedMB + " MB / " + totalMB + " MB";
  }
  
  // Update percentage display
  var percentElement = document.getElementById("downloadPercent");
  if (percentElement) {
    percentElement.textContent = percentage.toFixed(1) + "%";
  }
  
  // Update progress info text
  var progressElement = document.getElementById("downloadProgress");
  if (progressElement) {
    if (percentage > 0 && percentage < 100) {
      progressElement.textContent = "Downloading episode...";
    } else if (percentage >= 100) {
      progressElement.textContent = "Download completed!";
    } else {
      progressElement.textContent = "Starting download...";
    }
  }
}

function getRealDownloadProgress(nextEpisode) {
  // Query the server for real download progress from temp directory
  var msgId = nextEpisode.msg_id;
  
  // Use the new real progress endpoint
  fetch(SERVER + "/download/real_progress/" + msgId)
    .then(function(response) { return response.json(); })
    .then(function(progressData) {
      debug("üîç Server response: " + JSON.stringify(progressData));
      
      if (progressData.status === "downloading" && progressData.temp_file_found) {
        // We have real data from temp directory
        var totalSize = progressData.total_size;
        var downloadedSize = progressData.downloaded_size;
        var percentage = progressData.percentage;
        
        // Update state with real data
        state.videoPlayer.downloadProgress.totalSize = totalSize;
        state.videoPlayer.downloadProgress.downloadedSize = downloadedSize;
        state.videoPlayer.downloadProgress.percentage = percentage;
        
        // Update display with real data
        updateDownloadProgressDisplay(downloadedSize, totalSize, percentage);
        
        debug("üìä Real Server Progress: " + percentage.toFixed(1) + "% (" + 
              (downloadedSize / (1024*1024)).toFixed(1) + "/" + 
              (totalSize / (1024*1024)).toFixed(1) + " MB) from temp file: " + progressData.temp_filename);
              
      } else if (progressData.status === "downloading" && !progressData.temp_file_found) {
        // Download started but temp file not found yet
        var totalSize = progressData.total_size || (150 * 1024 * 1024);
        
        state.videoPlayer.downloadProgress.totalSize = totalSize;
        state.videoPlayer.downloadProgress.downloadedSize = 0;
        state.videoPlayer.downloadProgress.percentage = 0;
        
        updateDownloadProgressDisplay(0, totalSize, 0);
        debug("üìä Download starting, waiting for temp file...");
        
        // Also try the debug endpoint to see if files exist but aren't being detected
        fetch(SERVER + "/debug/temp_progress/" + msgId)
          .then(function(response) { return response.json(); })
          .then(function(debugData) {
            debug("üîß Debug data: " + JSON.stringify(debugData));
            if (debugData.temp_files_found > 0) {
              debug("‚ö†Ô∏è Debug found temp files but main endpoint didn't!");
              // Use debug data for now
              var debugDownloaded = debugData.downloaded_size || 0;
              var debugTotal = debugData.total_size || totalSize;
              var debugPercentage = debugData.percentage || 0;
              
              updateDownloadProgressDisplay(debugDownloaded, debugTotal, debugPercentage);
              debug("üìä Using debug progress: " + debugPercentage.toFixed(1) + "%");
            }
          })
          .catch(function(error) {
            debug("‚ùå Debug endpoint error: " + error.message);
          });
        
      } else if (progressData.status === "not_downloading") {
        // Download not in progress, episode might be ready
        debug("‚úÖ Download completed or not in progress");
        
      } else if (progressData.status === "file_info_unavailable") {
        // Fallback to estimation
        debug("‚ö†Ô∏è Cannot get real file size, using fallback estimation");
        fallbackProgressEstimation(nextEpisode);
        
      } else {
        // Error case
        debug("‚ùå Error getting real progress: " + (progressData.error || "Unknown error"));
        fallbackProgressEstimation(nextEpisode);
      }
    })
    .catch(function(error) {
      debug("‚ùå Error querying real progress: " + error.message);
      // Use fallback estimation
      fallbackProgressEstimation(nextEpisode);
    });
}

function fallbackProgressEstimation(nextEpisode) {
  // Fallback progress estimation when server data is unavailable
  var totalSize = nextEpisode.file_size || (150 * 1024 * 1024); // 150MB default
  
  // Initialize start time if not set
  if (!state.videoPlayer.downloadProgress.startTime) {
    state.videoPlayer.downloadProgress.startTime = Date.now();
  }
  
  var elapsedSeconds = (Date.now() - state.videoPlayer.downloadProgress.startTime) / 1000;
  
  // Conservative estimate: 1.5 MB/s average speed, cap at 90% until confirmed
  var estimatedDownloaded = Math.min(elapsedSeconds * (1.5 * 1024 * 1024), totalSize * 0.90);
  var percentage = (estimatedDownloaded / totalSize) * 100;
  
  // Update state
  state.videoPlayer.downloadProgress.totalSize = totalSize;
  state.videoPlayer.downloadProgress.downloadedSize = estimatedDownloaded;
  state.videoPlayer.downloadProgress.percentage = percentage;
  
  // Update display
  updateDownloadProgressDisplay(estimatedDownloaded, totalSize, percentage);
  
  debug("üìä Fallback Progress: " + percentage.toFixed(1) + "% (" + 
        (estimatedDownloaded / (1024*1024)).toFixed(1) + "/" + 
        (totalSize / (1024*1024)).toFixed(1) + " MB)");
}

// Event listeners and initialization
document.addEventListener("DOMContentLoaded", function() {
  // Season download confirmation buttons
  document.getElementById("confirmBtn").addEventListener("click", function() {
    hideSeasonDownloadModal();
    downloadWholeSeason();
  });
  
  document.getElementById("cancelBtn").addEventListener("click", function() {
    hideSeasonDownloadModal();
  });
  
  // Audio drawer close button
  document.getElementById("audioDrawerClose").addEventListener("click", function() {
    hideAudioDrawer();
  });
  
  // Register back key for Smart TV remotes
  if (typeof tizen !== "undefined" && tizen.tvinputdevice) {
    tizen.tvinputdevice.registerKey("Return");
  }
});

// Key listeners - ECMA 3 compatible
window.addEventListener("keydown", function(e) {
  handleKeyDown(e.keyCode);
});

window.addEventListener("keyup", function(e) {
  handleKeyUp(e.keyCode);
  
  // For non-Enter keys, use the regular handler
  if (e.keyCode !== 13 || state.view !== "seasons") {
    handleKey(e.keyCode);
  }
});

// Initialize the app
fetchSeries();

</script>
</body>
</html>